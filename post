#!/usr/bin/env perl

use strict;
use open ':utf8';
use Fcntl qw(:flock);
use JSON;
use CGI;
$CGI::POST_MAX = 4096;

my $query = new CGI;
my $thread_json;

if($query->request_method() != 'POST') { print $query->header(-status => '405 Method Not Allowed'); exit; }
$query->import_names('P');
bad_request() unless length($P::comment) > 0;
$P::thread = $P::thread + 0;
if($P::thread < 0) { $P::thread = create_thread($P::title, $P::comment); }
else { add_post($P::thread, $P::comment); }
print $query->header('application/json', '201 Created', -Location => thread_path($P::thread)), $thread_json;

sub bad_request()
{ print $query->header(-status => '400 Bad Request'); exit; }

sub thread_path($)
{ my ($thread) = @_;
  my $full = $ENV{'SCRIPT_NAME'};
  $full =~ s!/[^/]*$!/thread/$thread!;
  return $full; }

sub create_thread($$)
{ my ($title, $comment) = @_;
  bad_request() unless $title;
  open my $threads_file, '+<', 'threads';
  flock $threads_file, LOCK_EX;
  my $threads = decode_json(join '', <$threads_file>);
  my @threads = @{$threads}; 
  @threads[@threads + 0] = { 'id' => @threads + 0, 'title' => $title };
  seek $threads_file, 0, 0;
  print $threads_file encode_json(\@threads);
  flock $threads_file, LOCK_UN;
  close $threads_file;
  open my $thread_file, '>', "thread/$#threads";
  flock $thread_file, LOCK_EX;
  $thread_json = encode_json([$comment]);
  print $thread_file $thread_json;
  flock $thread_file, LOCK_UN;
  close $thread_file;
  return $#threads; }

sub add_post($$)
{ my ($thread, $comment) = @_;
  bad_request() unless -e "thread/$thread";
  open my $thread_file, '+<', "thread/$thread";
  flock $thread_file, LOCK_EX;
  my $thread = decode_json(join '', <$thread_file>);
  my @thread = (@{$thread}, $comment);
  seek $thread_file, 0, 0;
  $thread_json = encode_json(\@thread);
  print $thread_file $thread_json;
  flock $thread_file, LOCK_UN;
  close $thread_file; }
